# 静态分析基础技术

本章 / 从可执行文件提取有用信息 / 方法

- 使用反病毒软件来确认程序样本的恶意性
- 使用哈希来识别恶意代码
- 从文件的字符串列表、函数和文件头信息中发现有用信息

## 反病毒引擎扫描 

反病毒软件 / 主要依靠一个已知恶意代码可识别片段的特征数据库（病毒文件特征库），以及基于行为与模式匹配的分析（启发式检测）来识别可疑文件。

但是呢，病毒代码很容易变化，从而改变了程序特征来躲避了反病毒引擎的检测。而且，一些罕见的恶意代码也不会被识别，因为它们根本不在病毒文件特征库里。而且启发式检测也可能会被新型的恶意代码绕过。

所以使用多个反病毒软件进行扫描和检测是相当有必要的。

VirusTotal -- 上传文件并调用多个反病毒引擎来扫描 -- 生成报告 / 提供了所有引擎对样本的识别情况 / 标识样本是否是恶意 / 恶意代码名称 / 额外信息

## 哈希值：恶意代码的指纹

哈希，唯一标识恶意代码。恶意代码通过一个哈希程序产生一段用于唯一标识这个样本的独特哈希值，类似于指纹。 -- MD5算法 / SHA-1算法

一旦你对一个恶意代码样本拥有了一段独特的哈希值后，可以用来

- 将哈希值作为标签使用
- 分享哈希值帮助其他分析师识别恶意代码
- 搜索哈希值，判断这个文件是否已经被识别

## 查找字符串

Strings程序，搜索可执行文件中的可打印字符串。字符串存储格式：ASCII / Unicode

以NULL结束符表示字符串结束。ASCII 每个字符1个字节 / Unicode每个字符2个字节

如下图

![1-1](C:\Users\Ghz\Desktop\Practical-Malware-Analysis\1-BasicStaticTechniques\images\1-1.PNG)

![1-2](C:\Users\Ghz\Desktop\Practical-Malware-Analysis\1-BasicStaticTechniques\images\1-2.PNG)

Strings程序会搜索出 3个或以上连续的 ASCII / Unicode字符并噫NULL结尾的可打印字符串。所以，有些时候Strings识别的字符串并非是真正的字符串，需要用户自己过滤。

## 加壳与混淆恶意代码

使用加壳 / 混淆技术，是文件更难被检测or分析。混淆程序是恶意代码编写者尝试去隐藏其执行过程的代码，加壳属于混淆程序中的一类。加壳后的程序会被压缩并且很难分析。

合法程序通常会包含很多字符串。所以如果用Strings发现字符串很少--那么就可能是混淆的or加壳的 -- 也表明可能是恶意的。

### 文件加壳

![1-3](C:\Users\Ghz\Desktop\Practical-Malware-Analysis\1-BasicStaticTechniques\images\1-3.PNG)

### 使用PEiD检测加壳

![1-4](C:\Users\Ghz\Desktop\Practical-Malware-Analysis\1-BasicStaticTechniques\images\1-4.PNG)

如上图，PEiD识别处这个文件是被UPX版本0.89.6-1.02 or 1.05-2.09进行加壳的

对使用UPX加壳的恶意代码进行脱壳 --- 下载upx工具

```shell
upx -d PackedProgram.exe
```

## PE文件格式

可移植执行PE文件格式，是Windows可执行文件、对象代码和DLL所使用的标准格式。PE文件格式，其实是一种数据结构，包含为Windows操作系统加载器管理可执行代码所必要的信息。

PE文件以一个文件头开始，其中包括代码信息、应用程序类型、所需的库函数与空间要求。

## 链接库与函数

导入表 -- 导入函数

### 静态链接 、 运行时链接 、 动态链接

- 静态链接

  当一个库静态链接到可执行程序时，这个库中所有的代码都会复制到可执行程序中 --- 增大可执行程序，很难区分静态链接的代码or可执行程序自身代码（PE文件头中没有迹象表明这个文件包含有链接代码）

- 运行时链接

  在合法程序中并不流行，在恶意代码中常用，尤其是恶意代码被加壳或者是混淆时。使用 / 运行时链接 / 的可执行程序，只有在需要使用函数时才链接到库，而不是像动态链接那样在程序启动时链接。

- 动态链接

  当代码库被动态链接时，宿主操作系统会在程序被装载时搜索所需的代码库并链接。

一些Windows API运行导入 / 没有在程序 的头文件中列出的 / 链接函数。比如说 `LoadLibrary`, `GetProcAddress`, `LdrGetProcAddress`, `LdLoadDll`。`LoadLibrary`和`GetProcAddress`允许程序访问系统上任何库的任何函数，也就是说，当这些函数被使用时，无法静态分析出样本程序中会链接哪些函数。

PE文件头中存储了每个将要被装载的库文件，以及每个会被程序使用的函数信息。这些很重要。

### 使用Dependency Walker 探索动态链接函数

Dependency Walker ，支持列出可执行文件的动态链接函数。

#### 常见的DLL程序

| DLL                    | 描述                                       |
| :--------------------- | ---------------------------------------- |
| Kernel32.dll           | 包含核心系统功能 / 如访问和操作内存、文件和硬件等等              |
| Advapi32.dll           | 提供对核心Windows组件的访问 / 如服务管理器和注册表           |
| User32.dll             | 包含了所有用户界面组件 / 如按钮、滚动条以及控制和相应用户操作的组件      |
| Gdi2.dll               | 包含图形显示和操作                                |
| Ntdll.dll              | Windows内核接口，可执行文件通常不直接导入这个函数，而是由Knernel32.dll间接导入。如果一个可执行文件导入了这个文件，这意味着作者企图使用那些不是正常提供给Windows程序使用的函数，比如一些隐藏功能和操作进程任务等 |
| Wsock32.dll Ws2_32.dll | 联网DLL，访问其中任一个DLL的程序非常可能连接网络 or执行网络相关的任务  |
| Wininet.dll            | 包含了更高乘此的网络函数 / 实现了如 FTP、HTTP、NTP等协议      |

#### 函数命名约定

当微软更新一个函数 + 新函数与旧函数不兼容 + 微软仍会支持旧函数 === 新函数会有一个和旧函数相同的名字+Ex后缀。若更新了两次，就会有两个Ex后缀。

以字符串为参数的很多函数会有A/W后缀，这个A or W 在函数文档中并不出现 ： 以A结尾的输入参数类型为ASCII字符串，以W结尾的输入参数为宽字符字符串。

### 导入函数

Waaaa 微软通过MSDN库对Windows API进行了很出色的文档化

### 导出函数

通常，一个DLL会实现一个 or 多个功能函数，将它们导出，使别的程序可以导入并使用这些函数

DLL本身就是一些导出函数然后被EXE可执行文件使用，因此导出函数在DLL文件中很常见。然而要是在可执行文件EXE中发现导出函数，那么就可以分析一下了。

导出函数是可以随便命名的，所以恶意代码经常会省略名字 / 使用不明确or误导性的名字

## 静态分析技术实践

### PotentialKeylogger.exe ：一个未加壳的可执行文件

waaaaa 很多的导入函数的话 --- 证明没有被加壳

一些常用的函数:

- Kernel32.dll
  - OpenProcess / GetCurrentProcess / GetProcessHeap----  打开和操作进程
  - ReadFile /  CreateFile / WriteFile ---- 对文件进行操作
  - FindFirstFile  / FindNextFile --- 搜索一个目录下的所有文件
- User32.dll
  -  RegisterClassEx / SetWindowText / ShowWindow 图像化操作函数 -- 表示这个程序很可能使用了一个图形化界面
  - SetWindowHookEx -- 间谍软件常用 / 键盘记录器接收键盘输入
  - RegisterHotKey  --- 注册了一个热键，每当用户按下热键组合后便会通知应用程序。无论当前是哪个应用程序处于活动状态，热键都会将用户带到注册了热键的应用程序。

### PackedProgram.exe 



## PE文件头与分节

### 使用PEview来分析PE文件

### 使用Resource Hacker工具来查看资源节

### 使用其他的PE文件工具

### PE文件头概述

## 小结

## 实验

