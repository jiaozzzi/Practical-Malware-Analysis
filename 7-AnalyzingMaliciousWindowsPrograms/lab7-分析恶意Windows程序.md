# lab7-分析恶意Windows程序
## lab 7-1

分析lab07-01.exe
1. 当计算机重启之后，这个程序如何保证它继续运行(达到持久化驻留)
2. 为什么这个程序会使用一个互斥量
3. 可以用来检测这个程序的基于主机特征是什么
4. 检测这个恶意代码的基于网络特征是什么
5. 这个程序的目的是什么
6. 这个程序什么时候完成执行

## lab 7-2
分析lab07-02.exe
1. 这个程序如何完成持久化驻留
2. 这个程序的目的是什么
3. 这个程序什么时候完成执行

## lab7-3
执行前获得的恶意的可执行程序 lab07-03.exe 以及 lab07-03.dll，(恶意代码一旦执行就可能发生改变)，两个文件在受害者的机器上的同一个目录下被发现，如果运行这个程序，要确保两个文件在分析机器上的同一个目录中。一个以127开始的IP字符串(回环地址)连接到了本地机器。
warning：这个实验可能会造成损害，虚拟机记得事先做快照。then，动静态结合分析，聚焦全局视图，避免陷入细节。
1. 这个程序如何完成持久化驻留，来确保在计算机重启后仍能继续运行
2. 恶意代码基于主机特征（两个）是什么
3. 这个程序的目的是什么
4. 一旦这个恶意代码被安装，如何清除

----

题目如上，当然要先自己尝试一下了 (ง •_•)ง

---

## lab 7-1

### 基本静态分析

我们用 `PEiD` 来看一下导入函数

- `ADVAPI32.dll`

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab1/1.PNG)

    `OpenSCManager`函数返回服务控制管理器的句柄，`CreateService`函数添加一个新的服务到服务控制管理器，这两个API函数说明恶意程序很可能会创建服务来保证计算机重启后还能继续运行。

- `WININET.dll`

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab1/2.PNG)

    出现了 `InternetOpenUrl` 函数以及 `InternetOpen` 函数，说明这个程序可能会连接到 某个网址。

### 用 `IDAPro` 来做高级静态分析

`main`函数如下

![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab1/3.PNG)

可以看到 `StartServiceCtrlDispatcher` 函数，来实现一个服务，指定服务控制管理器所调用的服务控制函数，即 `sub_401040`。看 `main`函数只能知道会有一个服务要运行。
下面看一下 `sub_401040`。

程序首先调用了 `OpenMutexA`函数，它会获得一个 `HGL345`的互斥量，如果 `HGL345` 这个互斥量存在 则红线跳转，那么程序就会调用 `ExitProcess` ；如果互斥量不存在则绿线跳转，调用`CreateMutexA` 创建名为 `HGL345`的互斥量，保证恶意程序在任意时刻只有一份实例在系统上运行。

继续，看到 `OpenSCManagerA` 来打开服务控制管理器的句柄，恶意程序可以添加or修改服务。然后 调用 `GetCurrentProcess` 来获取当前进程的伪句柄，（伪句柄也就是说这个函数所获取的句柄可以被复制但是不能被继承，而且获取的这个句柄在程序的最后也不需要调用 `closeHandle`来关闭句柄）。往下，`GetModuleFileNameA`用以获取当前所运行程序或一个被加载的`DLL`的完整路径，后面调用 `CreateServiceA` 来创建一个服务，这个函数的参数 `lpBinaryPathName` 保存了刚才我们获取的当前运行程序的完整路径名， `dwStartType` 表示服务的启动选项 = 2 = `SERVICE_AUTO_STSRT` 表示服务在系统启动时自动运行。下一个 `dwServiceType` 表示服务的类型 = 10h 表示该服务运行于独立进程的服务程序。服务程序的名称即为`Malservice`。

继续，`xor edx,edx` 即将 `edx`置为0。然后看到程序使用了`SystemTime`，将`wYear`/`wDayOfWeek`/`wDayOfWeek`/`wDayOfWeek` = `edx` = 0，then， `wYear = 834h = 2100` 即2100年1月1日的午夜。then，`SystemTimeToFileTime` 将系统时间赋给文件时间。then，`CreateWaitableTimerA`/ `SetWaitableTimer`/ `WaitForSingleObject`。我们看一下 `SetWaitableTimer`的参数，`FileTime = edx = lpDueTime`表示要等待的时间，然后调用 `WaitForSingleObject`进入等待，一直到2100年1月1日的午夜这个程序才会继续执行。

如果现在的时间已经到了2100年1月1日的午夜，那么红线往下，`esi`作为计数器 = 14h = 20 进入循环，循环最后` dec  esi`，即 `esi--`，所以就是这个循环要执行20次。调用 `CreateThread`，参数 `lpStartAddress `表明哪些函数在线程创建后执行。查看参数，`InternetOpenA`初始化网络连接，进入循环，调用  `InternetOpenUrl`，循环末尾是 jmp无条件跳转 回起始位置，也就是说这是一个无限循环，不断调用 `InternetOpenUrl`来访问网址 `"http://www.malwareanalysisbook.com"`，返回上一层循环，上一层循环是循环20次，也就是要创建20个线程，每个线程不断调用`InternetOpenUrl`来访问网址。

所以，这个恶意程序就是一个`ddos`，也就是分布式拒绝访问的攻击。

### 回答问题：

1. 当计算机重启之后，这个程序如何保证它继续运行(达到持久化驻留)

    程序调用 `CreateService`来创建了一个服务 `MalService`来保证每次在系统重启后自动运行

2. 为什么这个程序会使用一个互斥量

    使用一个互斥量来保证程序在同一时间是有一份实例在运行

3. 可以用来检测这个程序的基于主机特征是什么

    - 互斥量 `HGL345`
    - 创建的服务 `MalService`

4. 检测这个恶意代码的基于网络特征是什么

    - 用户代理 "Internet Explorer 8.0"
    - url `"http://www.malwareanalysisbook.com"`

5. 这个程序的目的是什么

    等到2100年1月1日的午夜，创建线程，每个线程无限循环访问url `"http://www.malwareanalysisbook.com"`，就是一个分布式拒绝服务攻击。

6. 这个程序什么时候完成执行

    无限循环，永远不会完成。

---

## lab 7-2

### 基本静态分析

#### **Strings查看lab07-02.exe**

![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab2/1.PNG)

如上图，我们得到的有用的信息也就是上面那个网址了--


#### **dependency walker查看lab07-02.exe**

- `OLE32.DLL`

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab2/2.PNG)

    - `CoCreateInstance` 创建一个`COM`对象
    - `OleInitialize`    初始化组件对象模型库
    - `OleUninitalize`   关闭组件对象模型库

- `OLEAUT32.DLL`

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab2/3.PNG)

    2/6/8号函数，对应如下---与`COM`相关
    - `SysAllocString`  分配一个新的字符串，并将传递的字符串复制进去
    - `SysFreeString`   释放字符串
    - `VariantInit `    变量初始化


我们运行一下这个程序，可以看到它访问了网址/就是上面 `Strings`看到的那个网址

### **高级的静态分析--使用IDA Pro**

**自己看IDA Pro/无图 (ง •_•)ง**

`call OleInitialize` 初始化组件对象模型库,then, `call CoCreateInstance`来创建一个 `COM`对象 放到了`ppv`，如何看这个程序使用了`COM`的什么功能--看参数

**dd=32位  /  dw=16位  /  db=8位  / 一个十六进制数4位  / 6 dup(0) = 6个字节的0**

接口标识符`riid` = `D30C1661-CDAF-11D0-8A3E00C04FC9E26E` = `iwebbroser2`
```s
.rdata:00402068 ; IID riid
.rdata:00402068 riid            dd 0D30C1661h           ; Data1 ; DATA XREF: _main+14o
.rdata:00402068                 dw 0CDAFh               ; Data2
.rdata:00402068                 dw 11D0h                ; Data3
.rdata:00402068                 db 8Ah, 3Eh, 0, 0C0h, 4Fh, 0C9h, 0E2h, 6Eh; Data4
```

类标识符 `rclsid` = `0002DF01-0000-0000-C000000000000046` = `Internet Explorer`(查看注册表)
```s
.rdata:00402058 ; IID rclsid
.rdata:00402058 rclsid          dd 2DF01h               ; Data1 ; DATA XREF: _main+1Do
.rdata:00402058                 dw 0                    ; Data2
.rdata:00402058                 dw 0                    ; Data3
.rdata:00402058                 db 0C0h, 6 dup(0), 46h  ; Data4
```

`call ds:VariantInit`  变量初始化

`call ds:SysAllocString` 为字符串分配空间

后面 `ppv` -- `eax` -- `edx `

`call dword ptr [edx+2Ch]` 这个对象偏移0x2C处的一个函数被调用。在 `IPA Pro`中添加结构体 `Structures`栏--`Insert`键--`IntetfaceName` 创建标准结构体-- 查找 `iwebbroser2Vtbl`--添加。回去找2Ch 右键--改为 `[edx+IWebBrowser2Vtbl.Navigate]`, 也就是调用 `Navigate` 函数--允许程序启动 `Internet Explorer` 并且访问web地址。

then ，调用了一些清理函数。

ok分析完毕。

### 回答问题
1. 这个程序如何完成持久化驻留
    这个程序没有持久化驻留啊..../(ㄒoㄒ)/~~

2. 这个程序的目的是什么
    访问一个网页

3. 这个程序什么时候完成执行
    显示完网页，程序就结束了--完成执行

---


## lab 7-3

基础的静态分析--高级的静态分析--动态分析

### 基础的静态分析

#### **Strings查看lab07-03.exe**

- 可以看到有两个很相似的字符串 `kernel32.dll` 和 `kerne132.dll` ，这就是个伪造的 `kernel32`动态链接库

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/1.PNG)

- 这个 `.exe`表明恶意程序可能会对系统中的全部or部分exe程序进行一定的操作

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/2.PNG)

- then出现了两个路径：C盘的根目录和 kerne132.dll（假的）的路径，也就是说这个程序很可能将伪造的动态链接库文件copy到system32的目录下。

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/3.PNG)

- 字符串`lab07-03.dll`,说明我们当前的程序可能会对dll文件进行一定的操作

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/4.PNG)

#### **dependency walker查看lab07-03.exe**

来看程序的导入函数

- 可以看到 `CreateFile` 和 `CreateFileMapping`，也就是说这个程序很可能会创建一个文件并且把文件映射到内存。

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/5.png)

- `FindFirstFile`和 `FindNextFile`说明这恶意程序可能会在我们系统中搜索文件

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/6.png)

- `CopyFile`进行文件拷贝


#### **Strings查看lab07-03.dll**

- 这有一个ip地址，也就是说这个程序很可能会连接到这个ip地址

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/7.png)

#### **dependency walker查看lab07-03.dll**

- `ws2_32.dll`看到 `connect`/`listen`/`recv`/`send`等函数，也就是网络发送和接收数据。

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/8.png)

- `kernel32.dll`  `CreateProcess`函数很可能会创建进程。还有互斥量

    ![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/7-AnalyzingMaliciousWindowsPrograms/images/lab3/9.png)

这个`dll`文件没有导出函数，比较奇怪。一般`dll`文件存在的目的一般来说就是将自身的函数给别的程序使用。

### 高级的静态分析--使用IDA Pro

**自己看IDA Pro/无图 (ง •_•)ง**

#### `IDA Pro`查看`DLL`文件

函数挺复杂的===

我们只看`call`
- `__alloca_probe` 库函数，主要用于分配内存空间
- `openMutexA` + `CreateMutexA` 创建互斥量，保证同一时间恶意程序只有一个实例在运行
- `WSAStartup` + `socket` + `inet_addr` + `connect` + `send` + `recv` 接收和传输数据
- `shutdown`
- `sleep`
- `CreateProcessA` 创建进程

猜测，dll文件的作用：从一个远程计算机发送和接收命令


`call connect` 建立连接

`push` 一个IP地址 127.26.152.13

`push 50h = 80`（十进制） 尝试连接80端口

往下

`call send`

`push buf = 'hello'` 也就是要发送的数据，告诉远程服务器，hello我这个受感染的计算机准备接收你的命令了

往下

`call recv` 接收到的数据放在` buf = eax = [esp+120Ch+buf]`这个位置

再往下

`call strncmp`

5个字符，比较`str2`是否是`sleep`，如果是的话红线跳转，执行`Sleep`函数休眠60s。否则，继续往下，`call strncmp`，比较四个字符是否是`exec`，如果是`exec`的话红线跳转，`call CreateProcessA`，比较重要的参数是 `edx--lpCommandLine`，也就是要创建的进程的信息，但是现在怎么查看`lpCommandLine`是什么？

```s
buf= byte ptr -1000h
CommandLine= byte ptr -0FFBh
```
差5个字节，所以这个`CommandLine`的内容呐就是紧跟在`exec`后面的内容。也就是说为`exec`后面内容创建进程。然后跳回开始位置。也就是说这个`dll`程序不断接收指令。

所以呢，这个`dll`程序就是一个后门，允许攻击者发送消息来启动本地系统上的可执行文件。

#### IDA Pro查看`exe`程序

`argc->eax`，`argc`是`main`函数的第一个参数，也就是`main`函数的参数个数。then，`cmp eax, 2` ，如果 `eac ！= 2`，那么程序就直接结束了。

then，`argv->eax`，`argv`保存的是参数的具体内容，`eax+4`则指向了`main`函数的第二个参数，也就是说，`mov eax, [eax+4]` 将`main`函数的第二个参数保存在了`eax`里面，`warning 字符串`保存在了`esi`里面，然后cmp eax和warning字符串，如果不一样，程序最终就直接结束了。也就是说，这个程序正确运行的方式是`Lab07-03.exe WARNING_THIS_WILL_DESTROY_YOUR_MACHINE`。

继续往下，看到函数`CreateFileA`/ `CreateFileMappingA`/ `MapViewOfFile`将 `"C:\\Windows\\System32\\Kernel32.dll" `和  `"Lab07-03.dll"` 映射到内存。

`call sub_401040` / `call sub_401070`

两个 `call CloseHandle`,我们刚刚打开了两个文件的句柄映射到内存，所以现在调用两个 `CloseHandle`来关闭。

then `call CopyFileA`，将 `"Lab07-03.dll"`重命名并拷贝`"C:\\windows\\system32\\kerne132.dll" `（假的那个

then `call sub_4011E0`，参数为 `"C:\\*"`,进入 `sub_4011E0`, 参数 `lpFileName = "C:\\*"`，then， `FindFirstFileA`函数的参数为`lpFileName`，也就是说，在`C:\\*`上调用 `FindFirstFile`---搜索整个C盘。然后 `call malloc`分配内存， `call ds:_stricmp` 不区分大小写的字符串比较, 参数为``str1` 和 `.exe`， 比较成功的话 `call sub_4010A0` ，所以就是在C盘下寻找 `.exe`对比，成功则调用 `sub_4010A0`。

进入`call  sub_4011A0`，看到函数`CreateFileA`/ `CreateFileMappingA`/ `MapViewOfFile`将找到的 `.exe`程序映射到内存中，`IsBadReadPtr`用来检查进程是否有权限来访问指定的内存块。

再往下，`push  "kernel32.dll"/Str1 ` `call  _stricmp`,比较 `kernel32.dll` 和 `Str1`，如果相等的话红线跳转，看到 `repne scasb = strlen`求字符串长度，`rep movsd = memcpy`将 `esi的内容 = dword_403010` 覆盖到 `edi  = ebx = Str`1中。看一下 `dword_403010`,按 a 键转换为字符串， `db 'kerne132.dll'`。

所以，总之呐，这个恶意程序查找 C 盘下所有 `.exe`程序，然后在 `.exe`文件中找到 `kernel32.dll` 换成伪装的 `kerne132.dll`,也就是说，当这些 `exe`程序运行的时候就会自动加载这个假的 `kerne132.dll`。

ok 静态分析基本结束了

### 动态分析

虚拟机运行恶意程序，可以使用 `Process Moniotor`来监视。

假设你在C盘目录下放一个`.exe`程序，比如说 `Strings.exe`,那么恶意程序运行结束之后 `Strings.exe` 就会被感染，用 ·Dependency Walker·查看一下，确实可以看到其加载了`KERNE132.DLL`。假的 `KERNE132.DLL`下有真实的 `kernel21.dll`，也就是说假的 `KERNE132.DLL`也可以实现相应功能。

用 `Dependency Walker`看一下 `C:\\windows\\system32`下的 `KERNE132.DLL`程序，相对于 `lab07-03.dll` 可以看到有很多导出函数（e标识），这些导出函数呢就是将真实`kernel32.dll`中的函数进行重定向，以使假的 `KERNE132.DLL`也能实现真实的 `kernel21.dll`的功能。

### 回答问题
1. 这个程序如何完成持久化驻留，来确保在计算机重启后仍能继续运行
    这个程序在 `"C:\\windows\\system32"`目录下添加了一个DLL文件`kerne132.dll`(伪造 `kernel32.dll`),然后修改C盘下所有 `.exe`文件使其加载恶意的`kerne132.dll`，以达到持久化驻留。感染性的恶意程序。

2. 恶意代码基于主机特征（两个）是什么
    - 一个DLL文件`kerne132.dll`
    - 互斥量 `SADFHUHF`

3. 这个程序的目的是什么
    创建一个难以删除的后门连接远程主机，可以Sleep或者执行指令/创建进程

4. 一旦这个恶意代码被安装，如何清除
    感染性恶意代码哦。这个恶意程序感染了C盘中的所有`exe`文件，可以写一个程序用来修改被感染的文件的导入表中伪造的那个`KERNE132.DLL`改为真实的`kernel32.dll`。

    或者你可以从备份系统恢复。
