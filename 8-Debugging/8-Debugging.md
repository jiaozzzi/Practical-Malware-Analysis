# 8-Dubugging

​						------------------------------ 动态调试

### 源码级调试器 / 汇编级调试器

### 内核模式与用户模式

os只有一个内核，所以内核调试需要在两个系统上。进行内核调试时，一个系统运行被调试的代码，另一个运行调试器。配置os使其开启内核调试功能，并连通两个系统。

### 使用调试器

- `winDbg` = 唯一内核调试器 + 用户模式调试
- `OllyDbg` = 用户模式调试

调试方法：

- 用调试器启动程序
- 附加调试器到已经运行的程序

#### 单步调试

单步执行，调试器每执行一条指令就会产生一次中断

#### 单步跳过 / 单步跳入

单步跳过 `Stepping-Over` - - -函数一句调用，执行结束。可能有些函数永远不会返回2333 - - - `VMware record/replay`

单步跳入 `Stepping-Into`   - - - 进入函数内部，烦的时候 `Step-out`

#### 断点

有点意思的是，找到加密例程（加密函数）在数据被加密前设置断点 - - - 可以看到数据的明文

- 软件执行断点

  调试器通过使用`0xCC`，即指令` INT 3`的机器码，重写指令的首个字节来实现软件断点。当`0xCC`指令执行后，OS会产生一个异常，控制权转到调试器，即`0xCC`代表断点。就是说，当其他程序去读一个设有断点函数的内存，会读到一个`0xCC`

- 硬件执行断点

  处理器每次执行一个指令时，硬件检测指令的指针是否与断点地址相等。硬断点不关心断点地址存储了哪些字节，当调试修改自身的代码时，硬断点非常有用。

  优点：硬断点可以设置访问中断的断点 / 也就是说你可以设置一个硬断点，无论断点处的内存被读or被写都会引起中断。

  缺点：

  - 只有四个硬件寄存器存储断点的地址
  - 容易被运行的程序修改。CPU芯片有8个调试寄存器，但只有6个在使用，前四个`DR0 - - DR3` 存储断点地址，调试控制寄存器 `DR7` 存储` DR0` - -` DR7`寄存器中的值是否有效，以及它们是否表示读 / 写 / 执行断点等信息。恶意代码可以修改这些寄存器来干扰调试器。- - - - 令人欣慰的是 (ง •_•)ง  x86芯片具有防御该干扰的功能。设置 `DR7` 寄存器中的额通用探测(`General Detect`)标志位，**任何执行`mov`指令访问调试寄存器的操作都会触发中断**。

- 条件断点

  条件满足则触发断点 - - - 接收软断点，调试器计算条件，不满足自动继续执行，满足的话触发断点。

### 异常

- 首次 / 二次处理异常

  调试器第一次附加到进程时，会发生一个异常，被调试的程序停止执行，调试器开始获得控制权。调试器可以自己处理异常，也可以将异常转给被调试的应用程序处理。如果程序注册了异常处理函数，它会在调试器处理异常后获得处理异常的权限。

  如果应用程序没有处理异常，调试器会获得二次处理异常的机会。调试器接到了一个二次处理的异常，也就是意味着如果程序没有附加到调试器的话，程序就boom了。为了让应用程序正常运行的话，调试器就必须处理异常。

  一般来说，分析恶意代码不是找bug，所以首次异常处理经常忽略。二次异常处理不能忽略

- 常见异常

  最常见的是执行`INT 3`指令时产生的异常。调试器有专门的代码处理`INT 3`异常，而OS是把它和其他异常一样对待。应用程序可能包含处理` INT 3`异常的指令，但是附加调试器后，调试器会获得首先处理异常的权限。如果调试器将异常传给程序，程序的异常处理函数就会处理它。

  单步调试 - - - 作为异常才实现。设置标志寄存器中的陷阱标志` trap flag` ，`trap flag` 置位后，每执行一条指令就会产生异常。

  当程序试图去访问一个无权访问的内存时就会发生 内存访问冲突异常` memory access violation`。内存地址无效 / 访问无权访问的内存位置

  And，如果程序试图在非特权模式(用户模式)下 执行一些处于特权模式(内核模式) 才能执行的指令 - - - - 也会异常。

### 使用调试器修改可执行文件

修改 控制标志 / 指令指针 / 代码本身

ex 避免一个函数被调用 ：在函数被调用的位置设置断点，执行到断点时，将指令指针指向被调用函数之后的指令，从而避免函数调用。当然，你跳过函数之后，程序可能 不能正常运行 / boom / 没啥事。

----

填坑完毕，谢谢大家

---




