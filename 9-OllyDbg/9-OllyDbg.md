# 9-OllyDbg

## 加载恶意代码

### 打开一个可执行文件

`File` --`Open` -- `rguments`(参数)

默认 -- 断点在入口 `WinMain` / 否则在PE头部提供的入口点处中断

`Options` -- `Debugging Options` 可修改启动选项

### 附加调试器到一个运行程序

OllyDbg附加到一个正在运行的进程 `File` -- `Attach`

OllyDbg附加上进程后，进程当前执行线程的代码被暂停，并显示在OllyDbg的窗口中

## OllyDbg的接口

1. 反汇编面板窗口

    修改执行/数据 or 添加汇编指令 -- 按空格键

2. 寄存器面板窗口

    右键单击任意寄存器--`Modify`--修改寄存器的值

3. 栈面板窗口

    显示被调试线程堆栈在内存中的当前状态，总是显示给定线程的栈顶 -- 可右键 `Modify`

4. 内存转储面板窗口

    显示被调试线程的实时内存转储

    `Ctrl+G` -- 跳转到xx内存地址

    右键 -- `Binary` -- `Edit` 编辑内存

## 内存映射

内存映射窗口 `View` -- `Memory` 显示了被调试程序分配的内存块

可以双击内存映射中的任意一行，显示那个段的内存转储。也可以右击一段内存转储，`View in Disassembler`查看反汇编

### 基地址重定位

基地址重定位是指 Windows中的一个模块 没有加载到其预定基地址时发生的情况

**基地址**

Windows中所有PE文件都有一个预定的基地址，在PE文件头中被称为映像基地址

Windows允许映像基地址与要被加载到内存的实际地址不同。大部分执行程序会被预定加载到`0x00400000`处，这是Windows平台下大多数编译器使用的默认地址。不过，开发者可以选择将执行程序的基地址设置为一个与此不同的地址。支持地址空间布局随机化ASLR安全增强特性的可执行程序经常会被重定位。

一个应用程序可能导入多个DLL，每个DLL都有一个希望被加载到内存中的预定基地址。假设两个DLL有相同的预加载地址`0x10000000`，Windows就会将一个DLL加载到这个位置，另一个DLL重定位到某个地址。

**绝对地址和相对地址**

如果指令中使用了绝对地址来访问内存，如果这个文件被加载到预定基地址之外的另一个地址，访问这个地址就会出错。如果将这个文件加载到一个不同的地址，就需要改变这条指令。因此，多数DLL会在PE头的`.reloc`节打包一个修订位置的列表。

DLL在`.exe`载入后以任意顺序加载，这意味着如果DLL的基地址被重定位了，通常情况下不能预测DLL被定位到内存的什么位置。

DLL的重定位节也可以被移除，一个缺乏重定位节的DLL不能被加载到它的预定基地址，因此它也就不能加载。

DLL的重定位会影响性能，增加加载的时间。所有的DLL被编译时，编译器会为他们选择一个默认的基地址，通常这个默认的基地址对所有的DLL是相同的，极大增加了重定位的可能性。所以建议你，为DLL选择基地址来减少重定位。

IDAPro可能就不知道程序运行时会发生基地址重定位...

## 查看线程和堆栈

`View` --` Threads` 查看程序当前线程

OllyDbg是单线程的 -- 可能需要你先暂停所有线程，设置一个断点后继续运行程序，这样确保在一个特定线程内调试。

## 执行代码

OllyDbg运行代码选项

|功能|目录|热键|
|:--|:--|:--|
|Run / Play|Debug->run|F9|
|Pause|Debug->Pause|F12|
|Run to selection|Breakpoint->Run into Selection|F4|
|Run until return|Debug->Execute till Return|CTRL+F9|
|Run unti user code|Debug0>Execute till User Code|ALT+F9|
|Single-step / step-into|Debug->Step into|F7|
|Step-over|Debug->Step Over|F8|

通常在设置一个断点后，`Run`来继续执行

`Run to Selection` 表示在到达选择的指令前一直运行，如果选择的指令不被执行，那么被调试的程序就会一直运行下去。

`Execute till Return` 表示在当前函数返回时暂停执行，也就是这个函数不会终止的话被调试程序就会一直运行下去。

如果你的程序暂停到了库代码中，`Debug` -- `Execute till UserCode`可以使程序回到编译的恶意代码中

单步跳入F7 / 单步跳过F8

## 断点

默认软件断点 F2 / `View`-- `Breakpoints`

OllyDbg的断点选项

|功能|右键单击菜单选项|热键|
|:--|:--|:--|
|软件断点|Breakpoint->Toggle|F2|
|条件断点|Breakpoint->Conditional|Shift+F2|
|硬件断点|Breakpont->Hardware,on Execution||
|内存访问断点(读/写/运行)|Breakpoint->Memory,on Access|F2|
|内存写断点|Breakpoint->Memory,on Write||

### 软件断点

识别混肴字符串--在Decode函数的结束位置设置断点

### 条件断点

只有某些条件得到满足时才会触发断点

Warning：设置条件断点会大大降低程序的运行速度 / And 如果你设置了一个错误条件，那么将永远不会中断执行

对于调用频繁的API函数，可以设置，仅当特定参数传给他时触发断点

可以使用条件断点探测具有一定大小的内存分配。举个栗子。

Poison Ivy，一个后门病毒，接收大量shellcode -- 需要分配大量内存 -- 在`kernel32.dll`的 `VirtualAlloc`函数处设置条件断点 -- 分配内存>100时触发中断。首先我们在 `VirtualAlloc`函数开始处设置一个标准断点，然后运行程序直到命中断点

![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/9-OllyDbg/images/9-1.PNG)

上图，`VirtualAlloc`函数开始处的栈窗口。栈顶第一个元素是 `VirtualAlloc`函数的返回地址，接下来是四个参数(`Address` / `Size` / `AllocationType` / `Protect`)。本例中分配的内存大小为`0x29`字节，ESP寄存器存放栈顶指针，因此`[ESP+8]`指向分配内存的大小。我们设置一个 `[ESP+8]>100`的条件断点。

--右击 反汇编窗口的 `VirtualAllo`函数 -- `Breakpoint` -- `Conditonal` -- `[ESP+8]>100`

### 硬件断点

用专门的硬件寄存器设置硬件断点 -- 它可以在不改变你的代码、堆栈和任何目标资源的前提下进行调试 -- 也不会降低代码的执行速度 -- 但是只能同时设置4个硬件断点

在某一指令上设置硬件断点 --右击 `Breakpoint` -- `Hardware,on Execution`

### 内存断点

在一个内存块上设置断点 -- 可以让被调试程序在访问这段内存时中断执行。OllyDbg支持 软件内存断点 / 硬件内存断点 / 对内存执行读、写、执行or其他权限访问是否产生中断的设置

选择内存 -- 右击 `Breakpoint` -- `Memory,on Access`。

OllyDbg只允许设置一个内存断点，如果设置了新的内存断点，那么之前设置的内存断点会被移除

--- 应该有节制的使用内存断点

如果想知道恶意代码何时使用了某个加载的DLL，那么就可以设置内存断点，当DLL中的代码运行时程序被中断

1. 内存映射面板窗口 -- 右击需要跟踪的DLL的`.text`段(`.text`段保存了DLL的可执行代码)
2. Set Memory Breakpoint on Access
3. `F9` /`Play` 恢复程序执行

当程序运行到DLL的`.text`段时就会中断执行

## 加载DLL

OllyDbg可以调试DLL，因为DLL不能直接运行，所以OllyDbg使用`loaddll.exe`的虚拟程序来加载它。默认情况，DLL被加载后OllyDbg会在DLL的入口点`DllMain`处中断

如果要用参数来调用DLL的导出函数 -- 用OllyDbg加载DLL -- `Play`直到 `DllMain`执行结束--接下来OllyDbg会暂停DLL的执行，选择 `Debug` -- `Call DLL Export`--使用参数来调用DLL的导出函数并调试它。举个栗子

![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/9-OllyDbg/images/9-2.PNG)

我们加载的`ws2_32.dll`，在(1)调用了 `ws2_32.dll`中的 `ntohl`函数，`ntohl`函数的作用是 将一个32位数从网络字节序转化为主机字节序。在这里我们添加了一个参数 0x7F000001——数据127.0.0.1的网络字节序。

- --查看汇编代码 `Follow In Disassembler`
- --`Hide on call` 在函数调用后隐藏这个窗口
- --`Pause after call` 在导出函数被调用后立即暂停程序执行

要调试导出函数，请在函数调用前`Call` 设置断点--or 选中`Pause after call`

## 跟踪

### 标准回溯跟踪

当你在反汇编窗口上执行 `Step Into`和 `Step Over`时，OllyDbg会记录下这个操作--可以用减号-退回上一步运行的指令 or 加号+执行下一条指令

### 堆栈调用跟踪

通过堆栈跟踪可以查看一个给定函数的执行路径  `View` -- `Call Stack`--显示了当前位置之前的调用序列

### 运行跟踪

在运行代码时，OllyDbg会保存所有运行过的指令，以及它们运行过程中对寄存器和标志所做的改变

激活运行跟踪的办法

- 反汇编面板窗口 -- 高亮要跟踪的代码。右键 -- `Run Trace` -- `Add Selection`。代码运行后，选择 `View` -- `Run Trace`查看运行过的指令。减号-和加号+可以上下浏览代码。--这种方法可以查看每条指令执行时所有寄存器发生的变化
- 使用`Trace Into` 和 `Trace Over`选项。不需要选择需要跟踪的代码。 `Trace Into`可以单步执行并记录**命中断点前**所有的运行指令 /  `Trace Over`仅记录当前正在运行函数的指令。**Warning：**没有设置断点的情况下，只用`Trace Into`和 `Trace Over`会跟踪整个被调试程序--浪费时间浪费内存
- 选择 `Select Debug` -- `Set Condition`--可以在命中条件使程序暂停暂停之前，跟踪程序的运行。

### 跟踪Poison Ivy

Poison Ivy，为从命令和控制服务器接收的`shellcode`分配内存。Poison Ivy下载`shellcode`，复制它到动态内存中，然后执行。在某些情况下，当EIP指向Poison Ivy为`shellcode`分配的堆时，可以使用跟踪来捕获`shellcode`的运行。

设置EIP < 一个典型的映像位置(0x400000，低于此值是一些简单程序中的栈/堆/动态分配内存的存放位置)时--OllyDbg暂停 -- 正常程序中 EIP不会指向这些位置 -- 然后 `Trace Into`，即在`shellcode`运行之前整个程序被跟踪 -- OllyDbg即暂停在了`shellcode`的开始地址 -- 可以用减号-向后导航查看`shellcode`如何运行。

## 异常处理
默认情况下，OllyDbg被附加后会产生异常，附加程序也会停止运行，此时调试器会接管控制权。调试器可以处理该异常，也可以将异常转到被调试的应用程序处理。当异常发生时，OllyDbg会暂停运行，然后你可以选择以下任一种方法来决定是否将异常转到应用程序处理：

- `Shift+F7` 进入异常
- `Shift+F8` 跳过异常
- `Shift+F9` 将运行异常处理

OllyDbg提供异常处理的选项--如下图。这些选项可以告诉调试器忽略某些特定异常，并将它们转给应用程序处理(恶意代码分析期间跳过所有异常是个不错的选择，因为调试的目的并不是要处理这些异常)

![](https://github.com/braveghz/Practical-Malware-Analysis/blob/master/9-OllyDbg/images/9-3.PNG)

## 修补

OllyDbg可以很容易修改实时数据/ 如寄存器和标志。它也可以将汇编形式的修补代码直接插入到一个程序。-- 高亮选择--右击--`Binary`--`Edit`--添加操作码or数据

比如说 有一个条件跳转 JNZ来分别跳转到 Bad Key / Key Accepted -- 右键 `Binary` --`Fill with NOPs`(空指令) -- NOP指令替换了JNZ指令，程序会认为它接收了正确的密钥。

**Hint**这个仅仅改变了当前进程实例的内存，如果要把这种修改写入进程的执行文件 -- `Copy to executable` -- `All Modifications` -- 这个操作会复制进程内存中的任何修改 -- 会弹出新窗口 选择 `Save File` -- 用了两个NOP指令替换了JNZ指令 -- 恶意代码会接受任意输入的密钥

## 分析shellcode

简单方法

1. 将`shellcode`从一个十六进制编辑器复制到剪切板
2. 在内存映射面板窗口，选择类型为`Priv`的内存区域(这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享)
3. 双击内存映射面板窗口的某行，会弹出十六进制转储窗口 -- 该区域应该包含几百个连续为0的字节
4. 右击被选择的区域 -- `Set Access` -- `Full Access` -- 赋予该区域读/写/运行权限
5. 返回内存转储窗口。0字节填充的高亮区域足以容纳整个`shellcode`，右击选择的内存区域 -- `Binary` -- `Binary Paste`-- 复制粘贴
6. 设置`EIP`寄存器，指向修改的内存区域(设置EIP的值 -- 右击反汇编面板窗口的一条指令 -- `New Origin Here`)

And then，你可以正常运行/调试`shellcode`

## 协助功能

1. 日志 `Logging`

    OllyDbg维护一个持续可用的事件日志。`View` --`Log` 显示了加载的可执行模板 / 触发的断点 / 其他信息等。在分析过程中，日志可以帮助你找出未达到某一特定状态而执行的操作。

2. 监视窗口 `Watches`

    可以查看生成表达式的值。程序运行 -- 值更新。 `View` -- `Watches`--监视窗口 / 按空格键设置表达式

3. 帮助 `Help`

    `Help` -- `Contests` 说明

4. 标注 `Labeling`

    标注--为调试程序中的某个地址设置的简单符号名称。在反汇编窗口--右键--Label--设置完标注后，对这个地址的所有引用都会被标注代替

## 插件

下载链接*http://www.openrce.org/downloads/browse/OllyDbg_Plugins*

插件以DLL形式存在，将要安装插件的DLL放到OllyDbg的安装根目录下即可，OllyDbg会自动识别插件并添加到插件菜单

### OllyDump

OllyDump -- 可以将一个被调试的进程转储成一个PE文件

当加载器加载一个可执行文件时，OllyDump会尝试逆向这个进程 -- 最典型的应用就是脱壳(18章)

### 调试器隐藏插件

调试器隐藏插件用多种方法对探测者隐藏调试器的存在 -- 为了防止恶意代码使用反调试技术，在分析恶意代码期间一直运行调试器隐藏插件

这个插件主要针对 `IsDebuggerPresent`检测 /  `FindWindow`检测 / 未处理异常欺骗 / 用`OutputDebugString` 反OllyDbg调试 等反调试技术(16章)

### 命令行

命令行插件 -- 用命令行打开OllyDbg 

打开命令行窗口 `Plugins`-- `Command Line` -- `Command Line`

OllyDbg的命令行命令

|命令|功能|
|:--|:--|
|BP 表达式[，条件]|设置软件断点|
|BC 表达式|移除断点|
|HW 表达式|设置运行硬件断点|
|BPX 标注|设置调用标注函数时的断点|
|STOP/PAUSE|暂停|
|RUN|与逆行|
|G [表达式]|跳转到地址|
|S|Steo Into|
|SO|Step Over|
|D 表达式|转储内存|

调试时，经常需要在导入函数的入口处中断函数的执行，以查看传递给该函数的参数 -- 在导入函数入口处设置断点

`bp gethostbyname` --- 即在 `gethostbyname`函数入口处设置断点

### 书签

OllyDbg默认下自带书签插件 -- 可以将一个内存地址加到书签，下次直接找

右击反汇编面板窗口的地址 -- `Bookmark` -- `Insert Bookmark` -- 添加书签

`Plugins` -- `Bookmarks` -- `Bookmarks` -- 浏览书签

## 脚本调试

## 小结

